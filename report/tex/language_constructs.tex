\section{Language constructs}
The InvaderScript/ELFIE language has resulted in a highly declarative style of programming, focusing on what is to be done, but not how. While several of the concepts are widely used (events/signaling, class definitions, several design patterns), they have been modified to more specifically target the domain of role-playing games. This chapter focuses on describing and arguing for these specialised constructs.

\subsection{Class definitions}
\emph{make} allows for the inheritance from the adjusted core classes (called primarchs) of the base framework. While the Primarchs encompass several qualities often associated with object-oriented paradigms (encapsulation and inheritance), they also exhibit traits that detract from such a broad definition. In particular, primarchs and their seeds \todo{Find a better word for "children"} are highly specialised from their core, created for particular purposes within our bounded RPG framework \todo{Reference Biggi's analysis and ruleset}. Furthermore, Primarchs support no notion of class procedures, explicit instantiation or structural extendability. Any seed cannot change the first-level membership structure of its parent (it cannot add new members to the immediate structure, only modify existing members). Finally, InvaderScript does not support variables of any form. Any additions to a declaration happens by name of the type and nothing else. Note, however, that this is by no means a singleton pattern approach. While members of a Primarch are referenced by their type name, not an arbitrary variable, the code does not reference a static class, rather a nameless instance bound to the Primarch in question. The following is a list of the Primarchs inheritable within InvaderScript files:

\subsubsection{Character}
Defines any individual participant in the battle scenario. These are the root containers or associative centers for all other classes. While the Character primarch references the character's definition, it relies on the definitions of contained seeds of other primarchs to actually define it.

\subsubsection{Behaviour}
Details how a character's attributes and resources should be weighed according to each other as well as those of other characters. These weights define the character AI's "Piggy" value when calculating most beneficial actions mid-game. This forms half of the exposed mechanisms for modifying AI logic in InvaderScript, the other half being Events. 

\subsubsection{Ability} 
Key to describing a character's set of possible actions. Any action taken by a character will be described by an ability, from swinging a sword to weaving intricate spells and drinking potions. A seed of Ability defines the name, cost, possible targets and associated Effects of the ability. For example, swinging the sword may be accompanied by a PhysicalDamage Effect that defines how the ability will affect the game state.

\subsubsection{Event}
Events are largely analogous to the signaling features of many other languages (see events in C\#, Java, $C++$ and others) in that they are logic structures that register themselves to be notified when (or if) a particular state is reached. Once notified, the event reacts with appropriate action. In InvaderScript, Event primarchs are as declarative as any other primarch, and thus follows a very strict mechanic. Each Event defines a trigger for the event (known as a signal in the observer pattern) as well as an optional set of conditions that must hold for the event to follow through (for example, a Warrior's Blood Rage might trigger when the character drops in health, but only if he drops below $20\%$). Finally, the Event assigns a set of Ability references that will be attempted in sequence on the Character's next turn. Thus the Event primarch is the reactive half of the exposed mechanisms for defining AI behaviour (the other being Behaviour).\\

\\ \noindent The following is a list of Primarchs are referenced (and initialised) within other Primarchs, but must be defined within the external ruleset (see \vref{ref_external_rulebook}).

\subsubsection{Resource}
For values that can vary within a range. The primary example of a resource is the notion of health for a character, described as HP (Health Points or Hit Points). A resource defines a base value, a current value as well as maximum and minimum boundaries. Typically, resources are used as basis for winning conditions (reducing an enemy's health below a minimum limit, killing him).

\subsubsection{Attribute} 
In contrast to a resource, an Attribute is a single numeral without boundaries. An attribute would typically be applied when describing the strength, dexterity, intelligence or other simply denoted value for a character. These values are not expected to fluctuate like Resources, although they are by no means constant.

\subsubsection{Effect}
Must be contained and associated to Abilities. Each defines the result of applying an Ability to a target by a Character. Effects are unique in the current design \todo{Delete if irrelevant} in that they are the only primarch with a trait akin to a class constructor.

\noindent As described, primarchs have widely different uses, but are tightly connected to each other in order to discretely and precisely define the battle scenario by the programmer. They share no common ancestor, as they are each treated specially by the Batteru engine, revolving around the Character primarch. When a character's turn starts, the engine uses Behaviours associated with a Character to determine which of its known Abilities would result in the most beneficial game state. This is done by simulating the use of each Ability (applying the Ability's Effects) on every valid target and measuring the resulting Piggy value.

\emph{make} is the mechanism by which a primarch or seed is further specialised from its previous purpose. This is roughly equatable to inheriting in traditional object-oriented languages. \emph{make PhysicalDamage from Effect} creates a new Effect seed with all the defining features of Effect, while allowing the modification to the prior's definition.

\subsection{External ruleset}
\label{ref_external_rulebook}

\subsection{Ranges and random values}
The language has built-in support of random number generation, going so far as to allow variables with unknown actual values until they are used in an expression. These types were conceived to cater to the widely used concepts of dice throws and resources. Resources are quite often described with minimum and maximum values. Dungeons and Dragons, for example, define a character's minimum and maximum health points as a factor of their chosen profession (class) and Constitution attribute (a measure of physical endurance). Likewise, damage rolls (the combination of dice and modifiers used to calculate damage dealt from an attack) are formulated in the general form $xdyy+z$ where $x$ is the number of $yy$-sided die to roll, plus a constant $z$, determined by modifiers relevant to the roll (strength for melee, intelligence for magic, for example). These calculations and types of data are somewhat trivial to implement in imperative languages, but the sheer frequency of their use invites a vastly simplified syntax for the expression of the concept. Consider the following example: a damage roll defined as $3d8+2$ in C:
\begin{lstlisting}
int val = 2; // We know the constant.
for (int i = 0; i < 3; i++) // Run three times, matching 3 die.
{
    // Assume an effective pseudo-random number generator function.
    val += rand(1,8);
}
// val now contains the result of the calculation.
\end{lstlisting}
and in InvaderScript:
\begin{lstlisting}
result: 3*(1 to 8)+2;
\end{lstlisting}

\todo{Better syntax for dice rolls must be discussed! This will result in the same dice being multiplied. All non-multiples of 3 are not possible.}

Clearly, the InvaderScript syntax is much shorter and closer to the representation of the RPG rule books, simplifying the expression of random entropy \todo{redundant?} in a battle scenario.

\subsection{Inclusions}
A feature of primarch and seed definitions, inclusions \todo{proper term?} is a notation to define a member of a primarch without explicitly instantiating with an identifier. An example:
\begin{lstlisting}
make Fireball from Ability
{
	targets: [any];
	cost: [[user.mana, 10]];
	effects: [	FireDamage(target,5,12),
				BurnDOT(target,5,2 to 5)
			 ];
}

make Heal from Ability
{
	targets: [owner];
	cost   : [[user.mana, 7]];
	effects: [Heal(target,2d8)];
}

make BattleMageBehaviour from Behaviour
{
	positive : [[user.health, 70]];
	negative : [[team.enemy.health, 80]];
}

make Wizard from Character
{
	abilities : [Fireball, Heal, Attack];
	behaviour : BattleMageBehaviour;
	events    : [];
	items     : [];
                 
    Strength: 8;
    Dexterity: 8;
    Intelligence: 21;
    Wisdom: 17;
    
    Health: 80;
    Mana: 100;
}
\end{lstlisting}

In this example, we transcend Wizard from the Primarch Character, assigning new abilities and setting the value of attributes and resources as well as a proper behaviour. Notice that unlike imperative languages, only the type is given - no identifiers are necessary, since each entry of the type is considered unique (it is impossible to have two Strength attributes on the same character, both in the language and in by far most RPG systems).

\subsection{Relative Global References}
RGR's (or "RoGeRs") are a set of keywords that correlate to a dynamic set of global references. these are \emph{owner} \emph{enemy} \emph{target} to name a few, and will always reference the respective entity from the perspective of the local scope. \emph{enemy}, for example, will always reference the \textbf{other} Character in a battle when applied inside a Character subtype or its members, while \emph{owner} always references the topmost Character in a membership hierarchy. Consider the following code:

\begin{lstlisting}
make Fireball from Ability
{
	// Several mandatory members omitted for clarity.
	cost: [[owner.Mana, 10]];
}

make Wizard from Character
{
	abilities: [Fireball];
}

make Mage from Character
{
	abilities: [Fireball];
}
\end{lstlisting}

\emph{owner} when referenced in Fireball, will point to whichever Character is considering the ability. If it is the Wizard's turn and is calculating the use of the Fireball ability, \emph{owner} points to Wizard, not Mage. Essentially, this syntax approach wraps a parent-child relationship between objects (the hierarchy structucal design pattern) without the programmer having to specify these relationships explicitly. All of the RGR's thus automatically represent this relationship model, allowing the programmer to focus purely on the subtype at hand rather than the larger class architecture and the implications of n-element aggregation chains.

\subsection{Conclusion}

The reasoning for this minimalist approach is three-fold. Firstly, it results in increased writability/readability from the reduction of identifiers that need document referencing and memorization. Secondly, it vastly simplifies the style of writing for the definitions, much closer matching those of the character sheets that inspired them. Finally, the meticulous syntactical design creates a basis from which a much simpler language syntax is possible, allowing for an efficient compiler construction.