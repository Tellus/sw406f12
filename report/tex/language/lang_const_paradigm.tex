\subsection{Paradigm}
\label{language:paradigm}
As mentioned in the introduction to this chapter/section \todo{Correct?}, \langname{} has taken on traits of declarative programming languages that focuses on letting the programmer describe \emph{what} they want, but not necessarily \emph{how}. It is evident in the three basic interaction methods in the language: \emph{declaration}, \emph{assignment} and \emph{construction}. All three are demonstrate in the following snippet. \todo{Double check the syntax for Fireball.Costs - I can't remember how we referenced members like that.}

\begin{lstlisting}[language=fflang]
make Fireball from Ability
{
	Costs: [[user.Resources[Mana],-10]];
	Targets: [all];
	Effects: [
				[FireDamage(10,target)],
				[FireDot(3,3,12)]
			];
}
\end{lstlisting}

The user-defined type of Ability (Fireball) is declared and its member values are assigned the necessary values. Notice the syntax for each of the effects ($<EffectName>(<param_1>,...,<param_n>)$), reminiscent of procedure calls in many other languages, and indeed the best equivalent would be that of a class constructor. This code is all that is necessary in order to implement Fireball into the game and make it available to characters.
While not strictly adherent to any single rule system, each base type in the language models a particular part of systems that was deemed almost universal across those reviewed. For example, many actions (abilities) of characters have a cost associated with them, although not always linked so tangibly to a pool of resources like mana. As an example, 4th edition Dungeons \& Dragons limits the number of times an ability (called \emph{powers} in the system) can be used as a number of times per game day, encounter (battle) or "at will" (without restriction). Both types should be possible with the generalised assignment method and should thus cater to many different systems \todo{Test/confirm/analyse/look}. All other base types contain similar members (see the language reference for full descriptions).
The type members and the method of declaration (declare, assign, possibly construct) attempts to mimic the filling out of form-based pages in paper-based role-playing games. When a player (or \ac{dm}) fills out a character sheet, for example, they will line for line write in the current values for the character in appropriate fields \todo{Reference DnD or WoD sheets?}, erasing and updating values as necessary (when damage is taken, for example). Likewise, the programmer details the character as they should appear at the beginning of a battle according to a pre-defined rule set (that defines which types of Attribute, Resource and Effect are available), letting the engine handle the updating of values until conclusion.
This philosophy data-driven programming is further described within the context of several key areas of programming in the following sections.