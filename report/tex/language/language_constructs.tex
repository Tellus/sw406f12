\section{Language constructs}
The InvaderScript/ELFIE language has resulted in a generally declarative style of programming, focusing on what is to be done, but not how. While several of the concepts are widely used (events/signaling, class definitions, constructors, function calls), they have been modified to more specifically target the domain of role-playing games. This chapter focuses on describing and arguing these constructs, their purpose, usage and reasoning.

\subsection{Class definitions}
The \emph{core} and \emph{make} \todo{Possibly not make anymore.} keywords define a form of inheritance from the language's core classes (called primarchs). While the primarchs encompass several qualities often associated with object-oriented paradigms (encapsulation, instantiation, inheritance and polymorphism), they also exhibit traits that detract from such a broad definition. In particular, primarchs and their seeds \todo{Find a better word for "children"} are highly specialised from their core, created for particular purposes within our bounded RPG framework.

\begin{description}
	\item[Character] defines any individual participant in the battle scenario. These are the root containers or associative centers for all other classes. While the Character primarch references the character's definition, it relies on the definitions of contained seeds of other primarchs to actually define it.
	\item[Behaviour] details how a character's attributes and resources should be weighed according to each other as well as those of other characters. These weights define the character AI's Piggy value when calculating most beneficial actions.
	\item[Resource] is for values that can vary within a range. The primary example of a resource is the notion of health for a character, describes as HP (Health Points or Hit Points). A resource defines a base value, a current value as well as maximum and minimum boundaries.
	\item[Attribute] is, in contrast to a resource, a single numeral without boundaries. An attribute would typically be applied when describing the strength, dexterity, intelligence or other simply denoted value for a character. These values are not expected to fluctuate like Resources, although they are by no means constant.
	\item[Ability] is key to describing a character's set of possible actions. Any action taken by a character will be described by an ability, from swinging a sword to weaving intricate spells and drinking potions. A seed of Ability defines the name, cost, possible targets and associated Effects of the ability. For example, swinging the sword may be accompanied by a PhysicalDamage Effect that defines how the ability will affect the game state.
	\item[Effect] must be contained and associated to Abilities. Each defines the result of applying an Ability to a target by a Character. Effects are unique in the current design \todo{Delete if irrelevant} in that they are the only primarch with a trait akin to a class constructor.
\end{description}

As described, primarchs have widely different uses, but are tightly connected to each other in order to discretely and precisely define the battle scenario by the programmer. They share no common ancestor, as they are each treated specially by the Batteru engine, revolving around the Character primarch. When a character's turn starts, the engine uses Behaviours associated with a Character to determine which of its known Abilities would result in the most beneficial game state. This is done by simulating the use of each Ability (applying the Ability's Effects) on every valid target and measuring the resulting Piggy value.

\emph{make} is the mechanism by which a primarch or seed is further specialised from its previous purpose. This is roughly equatable to inheriting in traditional object-oriented languages. \emph{make PhysicalDamage from Effect} creates a new Effect seed with all the defining features of Effect, while allowing the addition (or modification) to the prior's definition.

The \emph{core} keyword can be considered a shorthand to \emph{make Primarch from Primarch}, as it allows the extension of a primarch without seeding. This is a feature for powerful readability, as it allows programmers to define core rules by re-defining well-known global names.

\subsection{Ranges and random values}
The language has built-in support of random number generation, going so far as to allow variables with unknown actual values until they are used in an expression. These types were conceived to cater to the widely used concepts of dice throws and resources. Resources are quite often described with minimum and maximum values. Dungeons and Dragons, for example, define a character's minimum and maximum health points as a factor of their chosen profession (class) and Constitution attribute (a measure of physical endurance). Likewise, damage rolls (the combination of dice and modifiers used to calculate damage dealt from an attack) are formulated in the general form $xdyy+z$ where $x$ is the number of $yy$-sided die to roll, plus a constant $z$, determined by modifiers relevant to the roll (strength for melee, intelligence for magic, for example). These calculations and types of data are somewhat trivial to implement in imperative languages, but the sheer frequency of their use invites a vastly simplified syntax for the expression of the concept. Consider the following example: a damage roll defined as $3d8+2$ in C:
\begin{lstlisting}
int val = 2; // We know the constant.
for (int i = 0; i < 3; i++) // Run three times, matching 3 die.
{
    // Assume an effective pseudo-random number generator function.
    val += rand(1,8);
}
// val now contains the result of the calculation.
\end{lstlisting}
and in InvaderScript:
\begin{lstlisting}
result: 3*(1 to 8)+2;
\end{lstlisting}

\todo{Better syntax for dice rolls must be discussed! This will result in the same dice being multiplied. All non-multiples of 3 are not possible.}

Clearly, the InvaderScript syntax is much shorter and closer to the representation of the RPG rule books, simplifying the expression of random entropy \todo{redundant?} in a battle scenario.

\subsection{Inclusions}
A feature of primarch and seed definitions, inclusions \todo{proper term?} is a notation to define a member of a primarch without explicitly instantiating with an identifier. An example:
\begin{lstlisting}
make Strength from Attribute
{
// Set relevant modifiers et al for this attribute.
}

make Fireball from Ability
{
	targets: (any);
	cost: (user.mana: 10);
	effects: (	FireDamage(target,5,12),
				BurnDOT(target,5,2 to 5)
			);
}

make BattleMageBehaviour from Behaviour
{
	positive(user.health, 70);
	negative(team.enemy.health, 80);
}

core Character
{
    Strength;
    Fireball;
    BattleMageBehaviour;
}
\end{lstlisting}

In this example, the Character primarch has been extended with an attribute, Strength, an ability (Fireball, complemented by the effects FireDamage and BurnDOT) and a Behaviour called BattleMageBehaviour. Notice that unlike imperative languages, only the type is given - no identifiers are necessary, since each entry of the type is considered unique (it is impossible to have two Strength attributes on the same character, both in the language and in by far most RPG systems). The reasoning for this minimalist approach is two-fold. Increased writability/readability from the reduction of identifiers that need referencing and memorization