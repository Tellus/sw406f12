\section{Language constructs}
The \langname language has resulted in a highly declarative style of programming, focusing on what is to be done, but not how. While several of the concepts featured in the language have well-known parallels in other programming languages (events/signaling, classes, inheritance, user-defined types), they have been modified to more specifically target the domain of role-playing games.

The very first few iterations of \langname{} presented a hybrid attempt between the implicitly understood effects of declarative programming with the flow control of imperative programming. As analysis of the target audience took hold, however, it became clear that the language should provide for simplistic input of objects \todo{classes?} and their relationships, without the hassle of considering line ordering or even algorithms. The focus should not be on having the programmers define the sometimes tedious rule sets and calculations of the games \todo{Reference WoD}, but rather let them take the natural role of a \ac{dm} and define not the world, but its contents. This has resulted in the unavoidably imperative elements of the language (in particular the rule set and base derivations of types) to be segregated into pre-written $C++$ code (the external ruleset) while the definition of characters and the setting of their attributes remains within \langname{}. This section \todo{change if we go higher/lower} describes the primary features of the \langname{} language as well as the underlying reasoning behind them.

\subsection{Paradigm}
\label{sec:language:paradigm}
As mentioned in the introduction to this chapter/section \todo{Correct?}, \langname{} has taken on traits of declarative programming languages that focuses on letting the programmer describe \emph{what} they want, but not necessarily \emph{how}. It is evident in the three basic interaction methods in the language: \emph{declaration}, \emph{assignment} and \emph{construction}. All three are demonstrate in the following snippet. \todo{Double check the syntax for Fireball.Costs - I can't remember how we referenced members like that.}

\begin{lstlisting}[language=fflang]
make Fireball from Ability
{
	Costs: [[user.Resources[Mana],-10]];
	Targets: [all];
	Effects: [
				[FireDamage(10,target)],
				[FireDot(3,3,12)]
			];
}
\end{lstlisting}

The user-defined type of Ability (Fireball) is declared and its member values are assigned the necessary values. Notice the syntax for each of the effects ($<EffectName>(<param_1>,...,<param_n>)$), reminiscent of procedure calls in many other languages, and indeed the best equivalent would be that of a class constructor. This code is all that is necessary in order to implement Fireball into the game and make it available to characters.
While not strictly adherent to any single rule system, each base type in the language models a particular part of systems that was deemed almost universal across those reviewed. For example, many actions (abilities) of characters have a cost associated with them, although not always linked so tangibly to a pool of resources like mana. As an example, 4th edition Dungeons \& Dragons limits the number of times an ability (called \emph{powers} in the system) can be used as a number of times per game day, encounter (battle) or "at will" (without restriction). Both types should be possible with the generalised assignment method and should thus cater to many different systems \todo{Test/confirm/analyse/look}. All other base types contain similar members (see the language reference for full descriptions).
The type members and the method of declaration (declare, assign, possibly construct) attempts to mimic the filling out of form-based pages in paper-based role-playing games. When a player (or \ac{dm}) fills out a character sheet, for example, they will line for line write in the current values for the character in appropriate fields \todo{Reference DnD or WoD sheets?}, erasing and updating values as necessary (when damage is taken, for example). Likewise, the programmer details the character as they should appear at the beginning of a battle according to a pre-defined rule set (that defines which types of Attribute, Resource and Effect are available), letting the engine handle the updating of values until conclusion.
This philosophy data-driven programming is further described within the context of several key areas of programming in the following sections.

\subsection{Program control and structure}
\label{ref_external_rulebook}
Program control and control structures refer to the mechanisms in a programming language that allows a programmer to define the order of execution of the code as well as conditional branching into subregions or even looping. \langname{} has almost none, going so far as to be completely order-agnostic with line ordering in-scope. \todo{Bad guess: our language is declarative, yes, and perhaps more specifically a functional derivative. While we have very little in the form of functions (see Effect()), we apply our assignments in basically the same manner. One could consider the assignment of values to members equal to the passing of function arguments, and the declaring of types to be the function calls themselves.}
The removal 
While a strict line ordering would better serve to give the impression of "form-filling" as prospective programmers would know it from pen and paper games, the loose ordering is simpler to parse and affords experienced programmers to lay out their code as they choose according to readability.

\subsection{Types and user-defined types}
Although \langname{} attempts to 
The core concepts of any roleplaying game necessitates a very rigid data structure, and the basis for \langname{} 's reference rule set is no different.
\emph{make} allows for the inheritance from the adjusted core classes (called primarchs) of the base framework. While the Primarchs encompass several qualities often associated with object-oriented paradigms (encapsulation and inheritance), they also exhibit traits that detract from such a broad definition. In particular, primarchs and their seeds \todo{Find a better word for "children"} are highly specialised from their core, created for particular purposes within our bounded RPG framework \todo{Reference Biggi's analysis and ruleset}. Furthermore, Primarchs support no notion of class procedures, explicit instantiation or structural extendability. Any seed cannot change the first-level membership structure of its parent (it cannot add new members to the immediate structure, only modify existing members). Finally, \langname{} does not support variables of any form. Any additions to a declaration happens by name of the type and nothing else. Note, however, that this is by no means a singleton pattern approach. While members of a Primarch are referenced by their type name, not an arbitrary variable, the code does not reference a static class, rather a nameless instance bound to the Primarch in question. The following is a list of the Primarchs inheritable within \langname{} files:

\subsubsection{Character}
Defines any individual participant in the battle scenario. These are the root containers or associative centers for all other classes. While the Character primarch references the character's definition, it relies on the definitions of contained seeds of other primarchs to actually define it.

\subsubsection{Behaviour}
Details how a character's attributes and resources should be weighed according to each other as well as those of other characters. These weights define the character AI's "Piggy" value when calculating most beneficial actions mid-game. This forms half of the exposed mechanisms for modifying AI logic in \langname{}, the other half being Events. 

\subsubsection{Ability} 
Key to describing a character's set of possible actions. Any action taken by a character will be described by an ability, from swinging a sword to weaving intricate spells and drinking potions. A seed of Ability defines the name, cost, possible targets and associated Effects of the ability. For example, swinging the sword may be accompanied by a PhysicalDamage Effect that defines how the ability will affect the game state.

\subsubsection{Event}
Events are largely analogous to the signaling features of many other languages (see events in C\#, Java, $C++$ and others) in that they are logic structures that register themselves to be notified when (or if) a particular state is reached. Once notified, the event reacts with appropriate action. In \langname{}, Event primarchs are as declarative as any other primarch, and thus follows a very strict mechanic. Each Event defines a trigger for the event (known as a signal in the observer pattern) as well as an optional set of conditions that must hold for the event to follow through (for example, a Warrior's Blood Rage might trigger when the character drops in health, but only if he drops below $20\%$). Finally, the Event assigns a set of Ability references that will be attempted in sequence on the Character's next turn. Thus the Event primarch is the reactive half of the exposed mechanisms for defining AI behaviour (the other being Behaviour).

\noindent The following is a list of Primarchs are referenced (and initialised) within other Primarchs, but must be defined within the external ruleset (see \vref{ref_external_rulebook}).

\subsubsection{Resource}
For values that can vary within a range. The primary example of a resource is the notion of health for a character, described as HP (Health Points or Hit Points). A resource defines a base value, a current value as well as maximum and minimum boundaries. Typically, resources are used as basis for winning conditions (reducing an enemy's health below a minimum limit, killing him).

\subsubsection{Attribute} 
In contrast to a resource, an Attribute is a single numeral without boundaries. An attribute would typically be applied when describing the strength, dexterity, intelligence or other simply denoted value for a character. These values are not expected to fluctuate like Resources, although they are by no means constant.

\subsubsection{Effect}
Must be contained and associated to Abilities. Each defines the result of applying an Ability to a target by a Character. Effects are unique in the current design \todo{Delete if irrelevant} in that they are the only primarch with a trait akin to a class constructor.

\noindent As described, primarchs have widely different uses, but are tightly connected to each other in order to discretely and precisely define the battle scenario by the programmer. They share no common ancestor, as they are each treated specially by the Batteru engine, revolving around the Character primarch. When a character's turn starts, the engine uses Behaviours associated with a Character to determine which of its known Abilities would result in the most beneficial game state. This is done by simulating the use of each Ability (applying the Ability's Effects) on every valid target and measuring the resulting Piggy value.

\emph{make} is the mechanism by which a primarch or seed is further specialised from its previous purpose. This is roughly equatable to inheriting in traditional object-oriented languages. \emph{make PhysicalDamage from Effect} creates a new Effect seed with all the defining features of Effect, while allowing the modification to the prior's definition.

\begin{comment}
%\subsection{Ranges and random values}
%The language has built-in support of random number generation, going so far as to allow variables with unknown actual values until they are used in an expression. These types were conceived to cater to the widely used concepts of dice throws and resources. Resources are quite often described with minimum and maximum values. Dungeons and Dragons, for example, define a character's minimum and maximum health points as a factor of their chosen profession (class) and Constitution attribute (a measure of physical endurance). Likewise, damage rolls (the combination of dice and modifiers used to calculate damage dealt from an attack) are formulated in the general form $xdyy+z$ where $x$ is the number of $yy$-sided die to roll, plus a constant $z$, determined by modifiers relevant to the roll (strength for melee, intelligence for magic, for example). These calculations and types of data are somewhat trivial to implement in imperative languages, but the sheer frequency of their use invites a vastly simplified syntax for the expression of the concept. Consider the following example: a damage roll defined as $3d8+2$ in C:

\subsection{Inclusions}
A feature of primarch and seed definitions, inclusions \todo{proper term?} is a notation to define a member of a primarch without explicitly instantiating with an identifier. An example:
\begin{lstlisting}
make Fireball from Ability
{
	targets: [any];
	cost: [[user.mana, 10]];
	effects: [	FireDamage(target,5,12),
				BurnDOT(target,5,2 to 5)
			 ];
}

make Heal from Ability
{
	targets: [owner];
	cost   : [[user.mana, 7]];
	effects: [Heal(target,2d8)];
}

make BattleMageBehaviour from Behaviour
{
	positive : [[user.health, 70]];
	negative : [[team.enemy.health, 80]];
}

make Wizard from Character
{
	abilities : [Fireball, Heal, Attack];
	behaviour : BattleMageBehaviour;
	events    : [];
	items     : [];
                 
    Strength: 8;
    Dexterity: 8;
    Intelligence: 21;
    Wisdom: 17;
    
    Health: 80;
    Mana: 100;
}
\end{lstlisting}

In this example, we transcend Wizard from the Primarch Character, assigning new abilities and setting the value of attributes and resources as well as a proper behaviour. Notice that unlike imperative languages, only the type is given - no identifiers are necessary, since each entry of the type is considered unique (it is impossible to have two Strength attributes on the same character, both in the language and in by far most RPG systems).

\subsection{Relative Global References}
RGR's (or "RoGeRs") are a set of keywords that correlate to a dynamic set of global references. these are \emph{owner} \emph{enemy} \emph{target} to name a few, and will always reference the respective entity from the perspective of the local scope. \emph{enemy}, for example, will always reference the \textbf{other} Character in a battle when applied inside a Character subtype or its members, while \emph{owner} always references the topmost Character in a membership hierarchy. Consider the following code:

\begin{lstlisting}
make Fireball from Ability
{
	// Several mandatory members omitted for clarity.
	cost: [[owner.Mana, 10]];
}

make Wizard from Character
{
	abilities: [Fireball];
}

make Mage from Character
{
	abilities: [Fireball];
}
\end{lstlisting}

\emph{owner} when referenced in Fireball, will point to whichever Character is considering the ability. If it is the Wizard's turn and is calculating the use of the Fireball ability, \emph{owner} points to Wizard, not Mage. Essentially, this syntax approach wraps a parent-child relationship between objects (the hierarchy structucal design pattern) without the programmer having to specify these relationships explicitly. All of the RGR's thus automatically represent this relationship model, allowing the programmer to focus purely on the subtype at hand rather than the larger class architecture and the implications of n-element aggregation chains.

\subsection{Conclusion}

The reasoning for this minimalist approach is three-fold. Firstly, it results in increased writability/readability from the reduction of identifiers that need document referencing and memorization. Secondly, it vastly simplifies the style of writing for the definitions, much closer matching those of the character sheets that inspired them. Finally, the meticulous syntactical design creates a basis from which a much simpler language syntax is possible, allowing for an efficient compiler construction.