\section{Language semantics}
\begin{comment}
The language is a language used for  of a role-playing characters. I addiction to the language is an battle engine, which simulates a battle between the  character. \\
The engine works, so that lets one character make an action, then the turn end, and the other character then gets to make its action. \\
The action a character makes, is calculated by an AI-behaviour. The AI-behaviour is base at a behaviour declared for the character. \\
Before a character gets to make its turn, win condition is checked, so that the character does not get to make an action if its health is below zero.  

\subsection{Environment-store model}
The semantics of the language is base at the environment-store model, which is a a model describing how variables are bound during a program execution. Each variable is bound to a storage cell, and the content of the storage cell is the value of the variable.

\subsection{\langname{} semantics}
\end{comment}

	%{\Large[The real stuff]}
The semantic of \langname{} is based at the environment-store model, described i section \ref{sec:semantic}.
The semantic is split in to two parts; decelerations in \langname{}, and the engine used for executing a battle between two declared characters.

In \langname{} it is possible for the user to use references, and thereby referring to a character. The references in \langname{} is called \ac{rgrs}, and in the definition of the semantic of \langname{}, a \ac{rgr} is the set of keyword used to refer characters. \textbf{RGR} is defined,  
%
$$\mathbf{RGR} = \{\texttt{owner, enemy}\}$$
%
\ac{rgrs} is used in the deceleration of abilities and behaviour. An ability is declared by a name and contains; the possible targets for the ability, an effect corresponding to the ability, a value representing the mana cost of the ability and a second value representing the damage done by the ability.

Therefore it is needed to keep track of the bindings of an ability, for this, an \textit{ability environment} is used. The set of ability environments is called \textbf{Ability}. 
Given an ability name \textit{AName}, an ability environment must hold information about, targets, effect, cost, and damage. Therefore the definition of the set of ability environments \textbf{Ability} is:
%
$$\mathbf{Ability: AName \rightharpoonup \mathcal{P}(RGR) \times Effect \times Integer \times Integer}$$
%
As mention \ac{rgr} is used for behaviour as well. A behaviour is declared by a name, and it contains a list of 3-tuples (\textbf{RGR}, \textbf{VName}, \textbf{Integer}), where \textbf{RGR} is the reference to the involved character, \textbf{VName} is the name of the involved attribute and \textbf{Integer} is a value representing the priority of the attribute.
When a character is declared, it is needed to keep track of the binding of the character. To keep track of the bindings a \textit{character environment} is used. The set of character environments is called \textbf{Character}.
Given a character name \textit{CName}, a character environment must hold information about the behaviour, abilities, attributes, event and resources bounded to the character. Therefore the definition of the set of character environment \textbf{Character} is:
$$\mathbf{Character} : \mathbf{CName} \rightharpoonup \mathbf{Behaviour} \times \mathbf{\mathcal{P}(AName)} \times \mathbf{EnvV} \times \mathbf{EName} \times \mathbf{Resource}$$
Character is decelerated from its name, and contains, behaviour, a list of abilities,, an environment which contain variables decelerated for the character, event, and its resources.  

Ability is decelerated from it name, and it contains, a \ac{rgr}, an effect and an integer which represent the cost of the ability, and an 			other integer which represent the damage(or heal) the ability does.

\ac{rgr} is the set of keyword, used for references.
$$\mathbf{Behaviour: BName \rightharpoonup \mathcal{P}(RGR \times VName \times Integer)}$$
$$\mathbf{Event : EName \rightharpoonup Trigger \times Condition \times AName}$$
$$\mathbf{Resource : RName \rightharpoonup Integer \times Integer}$$
		
\begin{table}
\begin{tabular}{l l}
\\ \hline \\
\small{\textsc{[Char-Dec]}} \\
 & \large{${\frac{\langle env, Health, Mana, sto, etc \rangle \; \Rightarrow \; env'}{\langle \texttt{make }  CName \texttt{ from } Character, \;
Name, A_D, R_D, Ability, Behaviour, Events\rangle}}$}\\
 & \footnotesize{$\Rightarrow env \; \vdash \; \langle sto, Attribute, HP, Integer \rangle$} \\
 \footnotesize{Where} $env'=$ &  \footnotesize{$env[Health \mapsto l] [\texttt{next} \mapsto \texttt{new } l, sto \mapsto std]$} \\
 & \footnotesize{$env[Mana \mapsto \texttt{new } l][\texttt{next } \mapsto \texttt{new new } l, sto \mapsto std]$} \\
 & \footnotesize{etc.} \\
 \\ \hline
\end{tabular}
\label{tbl:devC}
\caption{Transitions rules for Character deceleration, (\textsl{Remember to explain the ect.'s})}
\end{table}	

\begin{table}
\begin{tabular}{l l}
 \\ \hline \\
 \small{\textsc{[Event-Dec]}} & \\
 & \footnotesize{$\langle Char ,Ability, Behaviour, Event; \; Event EName, Trigger, Condition, AName \rangle ; \; S \Rightarrow$} \\
 & \footnotesize{$\langle Char, Ability, Behaviour, Event; Event[EName \mapsto (Trigger, Condition, AName)]; S \rangle$} \\
 \\ \hline
\end{tabular}
\label{tbl:devE}
\caption{Transitions rules for Event deceleration}
\end{table}

\begin{table}
\begin{tabular}{l l}
\\ \hline \\
\small{\textsc{[Ability-Dec]}}& \\
 & \footnotesize{$\langle Char, Ability, Behaviour, Event; \; Ability AName RGR, Effect, Int, Int \rangle \; \Rightarrow$} \\
 & \footnotesize{$\langle Char, Ability[AName \mapsto (RGR, Effect, Int, Int)], Behaviour, Event; S \rangle$} \\
\\ \hline
\end{tabular}
\label{tbl:decA}
\caption{Transitions rules for Ability declaration}
\end{table}

\begin{table}
\begin{tabular}{l l l}
\\ \hline \\
\small{\textsc{[Behaviour-Dec]}} & \\
 & \footnotesize{$\langle Char, Ability, Behaviour, Event; Behaviour BName,$} & \footnotesize{$RGR_1, VName_1, Integer_1$} \\
 & & \footnotesize{$RGR_2, VName_2, Integer_2$}\\
 & & \footnotesize{$RGR_3, VName_3, Integer_3$} \\
 & & \footnotesize{$\vdots$} \\
 & & \footnotesize{$RGR_n, VName_n, Integer_n  \rangle ; S \; \Rightarrow$} \\
\end{tabular}
\begin{tabular}{l p{0.92\textwidth}}
 & \footnotesize{$\langle Char, Ability, Behaviour', Event \rangle; S$} \\ %& \color{white} \footnotesize{$RGR_1, VName_1, Integer_1 \Rightarrow$} \\
\footnotesize{Where $Behaviour' = $} & \footnotesize{$Behaviour[BName \mapsto {\bigcup^{n}_{i = 0}} (RGR_i, VName_i, Integer_i)]$} \\
\\  \hline 
\end{tabular}
\label{tbl:decB}
\caption{Transition rules for Behaviour deceleration}
\end{table}

\begin{table}
\begin{tabular}{l l}
\\ \hline \\
\small{\textsc{[Turn]}} & \\
 & \footnotesize{$Char, Behaviour, Ability, Event, Resource \vdash \langle Active, Next, sto \rangle \Rightarrow \langle Next, Active, sto \rangle$} \\
 \\
\footnotesize{Where} & \footnotesize{$Char(Active) = (Behaviour, \mathcal{P}(AName), env, Ename, Resource)$} \\
\footnotesize{And} & \footnotesize{$Env(Health) > 0$} \\
 & \footnotesize{$\forall e \in Events. Event(e) \rightarrow_b f \! \! f$} \\
 & \footnotesize{$Be = Behaviour(Beh)$} \\
\\ \hline
\end{tabular}
\label{tbl:Turn}
\caption{Transition rules for Turn.}
\end{table}

\begin{table}
\begin{tabular}{l l}
\\ \hline \\
\small{\textsc{[Ability-Exe]}} & \\
& \footnotesize{$Char_{Active}, Char_{Next}, Ability \vdash \langle AName, sto \rangle \Rightarrow \langle sto[Char_{Active}(Mana) \; -\!\! = cost] \rangle$} \\
\footnotesize{Where} & \footnotesize{$ef\!f = (enemy, ef\!f, cost, ef\!fMana)$}\\
 & \footnotesize{$ef\!fect(sto, Char_{Next}, ef\!fMana) = sto'$}\\
\\ \hline
\end{tabular}
\label{tbl:abi-exe}
\caption{Transition rules for execution of an ability}
\end{table}


\begin{table}
\begin{tabular}{l l}
\\ \hline \\
\small{\textsc{Physical-Dmg}} & \\
 & \footnotesize{$Physical \langle sto, l \rangle \Rightarrow sto[l \mapsto x - i]$} \\
 \\ \hline
\end{tabular}
\label{tbl:physical}
\caption{Transition rule for Physical damage}
\end{table}

%%%%%%%%%%%%%
% Vi har nogle regler der skal beskrives med brødtekst.
% Kan ikke lige huske hvilke der mangler lige nu.. Det håber jeg at Danny kan hjælpe med at huske........
%%%%%%%%%%%%%
\begin{comment}
Five parts are highlighted for semantic description, these are  \emph{Declaration}, \emph{Turn}, \emph{AI}, \emph{Action} and \emph{Wincon}.\\
The first one 'Declaration' is the main function of \langname{} and the four that follow are not included in the language itself but in the engine.
A turn is a character takes an action, based at the outcome of the AI calculation \\
AI is calculation, which simulates every possible outcome, based on the possible actions a character can make. \\
Action is an event, which will make change for the stored values of the enemy character, or the character itself.\\
Wincon is a conditional check to see if the \emph{winning condition} is met.\\\\


The semantics for the relevant parts of \langname{} are defined as follows:
\begin{itemize}
	\item $EnvD$ is a declaration-environment
	\item $env_{D}$ is an element in the set $EnvD$
	\item $EnvC$ is a character-environment
	\item $env_{c}$ is an element in the set $EnvC$
	\item $StoreS$ is a set of locations and their bindings
	\item $sto$ is an element in the set $Stores$
	\item $Pending$ is a list of pending characters
	\item $ActioN$ is a set of available actions
	\item $act$ is an element in the set $ActioN$
\end{itemize}
\pagebreak
The rules for the five parts are as follows:
\begin{center}
\begin{tabular}{ c }
\textbf{Declaration}\\
\hline
 \\
$\langle env_{D}, env_{C}, sto \rangle \rightarrow$\\
$\langle env_{C}', sto' \rangle$\\
\end{tabular}
\end{center}
The transitions system for declarations is $(\Gamma_{DV}, \rightarrow_{DV}, T_{DV})$, whose configurations are defined by \\
\begin{tabular}{l l l}
$\Gamma_{DV}$ & $=$ & $(EnvD \times EnvC \times StoreS) \cup (EnvD, StoreS),$ \\
$T_{DV}$ & $=$ & $EnvC \times StoreS$ \\
\end{tabular}
\begin{center}
\begin{tabular}{ l l }
\multicolumn{2}{c}{\textbf{Turn}}\\
\hline
 & \\
$\langle Pending, env_{C}, sto \rangle \Rightarrow$ & \\
$\langle Pending', env_{C}, sto \rangle$ & $\text{if wincon } \rightarrow_{b} ff$\\
 & \\
$\langle Pending, env_{C}, sto \rangle \Rightarrow$ & \\
$\langle Pending, env_{C}, sto \rangle$ & $\text{if wincon } \rightarrow_{b} tt$\\
\end{tabular}
\end{center}

The transition system for turns is $(\Gamma_{TURN}, \Rightarrow_{TURN}, T_{TUNR})$, whose configurations are defined by\\
\\
\begin{tabular}{l l l }
$\Gamma_{TURN}$ & $=$ & $(Pending \times EnvC \times StoreS)$ \\
$T_{TURN}$ & $=$ & $(Pending \times EnvC \times StoreS)$\\
\end{tabular}

\begin{center}
\begin{tabular}{ c }
\textbf{AI}\\
\hline
 \\
$\langle Pending, env_{C}, sto, Action \rangle \Rightarrow$\\
$\langle Pending, env_{C}, sto, act \rangle$\\
\end{tabular}
\end{center}
The transition system for AI is $(\Gamma_{AI}, \Rightarrow_{AI}, T_{AI})$, whose configurations are defined by \\
\begin{tabular}{l l l }
$\Gamma_{AI}$ & $=$ & $(Pending \times EnvC \times StoreS \times ActioN)$ \\
$T_{AI}$ & $=$ & $(Pending \times EnvC \times StoreS \times ActioN)$ \\

\end{tabular}
\begin{center}
\begin{tabular}{ c }
\textbf{Action}\\
\hline
 \\
$\langle env_{C}, Pending, sto, act \rangle \Rightarrow$\\
$\langle env_{C}, Pending, sto', act \rangle$\\
\end{tabular}
\end{center}
The transition system for Action is $(\Gamma_{ACT}, \Rightarrow_{ACT}, T_{ACT})$, whose configurations are defined by \\
\begin{tabular}{l l l }
$\Gamma_{ACT}$ & $=$ & $(Pending \times EnvC \times StoreS \times ActioN)$ \\
$T_{ACT}$ & $=$ & $(Pending \times EnvC \times StoreS \times ActioN)$ \\

\end{tabular}
\begin{center}
\begin{tabular}{ l l }
\multicolumn{2}{c}{\textbf{Wincon}}\\
\hline
 & \\
$\dfrac{env_{C} \vdash c \rightarrow_{h} h}{\text{win} \rightarrow_{b} ff}$ & $\text{if } h > 0$\\
 & \\
$\dfrac{env_{C} \vdash c \rightarrow_{h} h}{\text{win} \rightarrow_{b} tt}$ & $\text{if } h \leq 0$\\
\end{tabular}
\end{center}
Wincon is special, because it is a boolean expression. \\
The rules evaluates true, if the demanded character $c$, has health evaluating to the value $h$, and the value is less or equal to zero, else et evaluates false, and the game will the continue.

\pagebreak


	$D_C ::= \text{make } c \text{ from } Character C \{ D_A, D_R, D_B \}; D_C | \varepsilon$\\
	%D_C is a declaration of a character
	$D_A ::= A: v; D_A | \varepsilon$\\
	%D_A is a declaration of an attribute
	$D_R ::= \text{make } r \text{ from } Resource: v; D_R | \varepsilon$\\
	%D_R is a declaration of a resource
	$D_{AB} ::= \text{make } ab \text{ from } Ability \{ List[Rgr], List[effects], cost_h, cost_m \}; D_{AB} | \varepsilon$\\
	%D_{AB} is a declaration of an ability
	%cost_h is health cost
	%cost_m is mana cost
	$D_B ::= \text{make } b \text{ from } Behaviour \{positiv | negativ : [Rgr.member, v]\}; D_B | \varepsilon$\\
	%D_B is a declaration of a behaviour

	
	$D_C \in Env_C$\\
	$D_A \in Env_A$\\
	$D_R \in Env_R$\\
	$D_B \in Env_B$\\
	$D_{AB} \in Env_{AB}$\\
	$D_E \in Env_E$\\
	\\
	
	$\mathbf{Env_A} = \textbf{Att} \cup \{ \texttt{next} \} \rightharpoonup \mathbf{Loc}$\\
	%Att is the id of an ability
	%next is the next available loc
	%loc is the location
	$\mathbf{Sto_A} = \textbf{Loc} \rightharpoonup \mathbb{Z}$\\
	% Z is the value of attributes
	\\
	$\mathbf{Env_R} = \textbf{Res} \cup \{ \texttt{next} \} \rightharpoonup \mathbf{Loc}$\\
	%Res is the id of a resource
	$\mathbf{Sto_R} = \textbf{Loc} \rightharpoonup \mathbb{Z}$\\
	\\
	$\mathbf{Env_B} = \textbf{Beh} \cup \{ \texttt{next} \} \rightharpoonup \mathbf{Loc}$\\
	%Beh is the id of a behaviour
	$\mathbf{Sto_B} = \textbf{Loc} \rightharpoonup \mathbb{Z}$\\
	\\
	


[Act-New]\\
	$env_c, sto \vdash \langle calc:A, s \rangle \Rightarrow \langle s'; calc:A', s \rangle$\\
	where $s' = env_c, sto \vdash s[piggy \mapsto v]$\\
	and $A' = Action[new]$\\
	
[Act-Empty]\\
	$env_c, sto \vdash \langle calc:A, s \rangle \Rightarrow \langle s \rangle$\\
	where $A = \varepsilon$\\
	\\	1
	\end{comment}
\begin{comment}
	[Turn]\\
	%1\\
	\\
	\\
	\\
	\\
	---------------------------------\\

	
	sideb-- 
	
	
	\\
	
\pagebreak
%	$env[Health \mapsto l] [next \mapsto new l, sto \mapsto
%	sto$]\\\\
%	-------------------------------------\\
 % $ \frac{$
	
	%[Event-Dec]\\

%	\\\\
	
%	\\
%	\\
%	\\\\
	

	\\
	\\
	.\\
	.\\
	.\\
	\hfill \\
	$\rightarrow$\\
	\\
	
	Yay declarations.... almost done
	\\\\
	\end{comment}