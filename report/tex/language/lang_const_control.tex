\subsection{Program control and structure}
Program control and control structures refer to the mechanisms in a programming language that allow a programmer to define the order of execution of the code as well as conditional branching into subregions or even looping. \langname{} has almost none, going so far as to be completely order-agnostic with line ordering in-scope. 
%\todo{Bad guess: our language is declarative, yes, and perhaps more specifically a functional derivative. While we have very little in the form of functions (see Effect()), we apply our assignments in basically the same manner. One could consider the assignment of values to members equal to the passing of function arguments, and the declaring of types to be the function calls themselves.}
The form-filling tendencies of the language are quite evident in this aspect. While a strict line ordering would better serve the metaphor, the loose ordering is simpler for a compiler to parse \todo{Are we sure that is true?} (avoiding an unknowable number of extra passes required for a proper semantic analysis) and affords experienced programmers to lay out their code as they choose according to readability. As a partial consequence, there are no conditional or iterative control structures. \todo{Can I rationalise this?}
Again the reasoning for this design choice stems from the target user group. While not necessarily a complex task, the algorithmic design activities involved when applying control structures to a problem are not commonplace within the role-playing community. Instead of forcing down a framework for conditional reasoning over the users, \langname{} instead moves these principles into an predefined rule set.
%If specific conditions change the state of a character, or their definition relies on the iterative execution of logic, it is handled externally and passed into the final character as necessary by the Engine.
A goal of the language design is to keep it sufficiently simple for novice programmers (and non-programmers) to work with, conditionals would primarily increase the amount of work involved in defining the battle. If they were to be introduced in \langname{}, the users would also need to work with object references, signaling and inheritance.
%This is due to the fact that anything that modifies a value in transition from one character to another (for example, damage) must be handled by the engine. If the programmer wants to catch and modify this, they must register for appropriate events, reference involved characters, modify the transition value according to the rules and send it back into the pipeline. The code could further be improved if this was handled in a subclass of the appropriate \langname{} base class. Thus it is not enough to simply introduce the necessary language construct.
%Instead, the rule set is specified externally as a subclass of the Engine-defined RuleSet class 
%\todo{reference documentation and/or name/architecture check} 
%(see \\ref\{wherever\}) programmed in $C++$, and used as a reference by the Engine when running the simulation.