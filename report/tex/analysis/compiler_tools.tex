\section{Compiler Construction Tools}

  When creating a compiler for a programming language, several tools which can automate part
  of, or even the entire process, exist. These tools are split into parts that correspond to 
  the different parts of a compiler.
  
  \subsection{Scanner Generators}
  
    Scanner generators, such as Lex \ref{yacchome}, require the user to create a set of rules
    for the tokens the compiler should recognize, often using some form of regular expressions,
    combined with what it should do for each of these tokens, often putting it on some form
    easily interpreted by a parser.
    \\
    Lex output c code which can easily be implemented in a complete compiler, with a function that
    generates tokens. It is up to the programmer to create, either by hand or using a parser
    tool, the functionality to handle these tokens.
    \\
    Ambiguous token definitions may or may not be handled by a scanner generated in this way,
    for example in Lex, if two rules match the current point in the input stream, it will
    choose the rule matching most characters. If the same amount of characters are matched,
    Lex will use the rule defined first.
    
  \subsection{Parser Generators}
    
    Parser generators, such as Bison \ref{yacchome}, generates a parser for a language, using a
    context free grammar as input. The format of this context free grammar depends on the
    generator in question, in the case of Bison, something similar to Backus-Naur Form is used.
    \\
    Bison, like Lex, outputs c code with a function to parse a file. This function expects a
    scanner function, such as the one generated by Lex, to be present. Bison allows you to define
    actions for what happens with successful parsing of a grammar rule, in simple cases the parser
    may be enough to generate the desires output, but for most programming languages, a parser will
    build an abstract syntax tree for various semantic checks and code generation.
    
  \subsection{Full Spectrum Compiler Construction Systems}
  
    Some tools, such as Gentle \ref{gentlehome} allow the generation of an entire compiler, including
    scanner, parser, tree traversal and code generation. These tools requires input in the form of
    rule definitions, for tokens, grammar and actions, and output a compiler able to translate a source
    language into a target language.
    
  \subsection{Pros and Cons of Automation}

	For languages with a large amount of token and grammar rules, using automated tools, can save
	a lot of time compared to creating the tools by hand. Making adjustments in the language which
	require a restructuring of for example the parser, is less of an issue when a tool is able to
	generate a new one without much work being done.
	\\
	For a small language however, crafting a compiler by hand can be faster, since you do not have
	to learn the format of the input the tools need to work. Additionally, when hand-crafting a compiler
	it is possible do custom optimizations, like for example creating the parser from e human-readable
	grammar, instead of having to create grammar rules specifically to optimize the output of the tool.
	
    
%TODO References: yacchome: http://dinosaur.compilertools.net/
%TODO References: gentlehome: http://gentle.compilertools.net/