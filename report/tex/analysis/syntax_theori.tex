\section{Syntax theory}
\todo{RENE SKRIV DETTE HER}
Some general information about syntax, what, why, how....
\subsection{Regular expressions}
\ac{regex} provides flexible means to recognise words and text. \ac{regex} can be very useful when manipulating text or searching for occurrences of certain strings.\\
Programming languages generally have some basic symbols, these could be ``expression'', ``value'', ''declaration'' etc. \ac{regex} is used by many compilers to recognise these types of symbols.
One of the ways to specify the structure of a language's syntax and ''basic symbols'' is with the use of \ac{regex}.\cite{Fischer2010}\\
One could think of \ac{regex} as a form of a pattern with the option for more control over the number of strings that get matched. A specific word could be written in two ways, for example, American english and British english often make use of the same word with one alphabetical letter changed. Let's say we want to match the word ''recognize''. Given the fact that some are likely to write it like this: ''recognise'', we want to match both cases. With a \ac{regex} we can specify it as such; <recogni(s|z?)e>. This way both words get matched.\\

\ac{regex} is built, using regular operations, these operations are; union ``$\cup$'', concatenation ``$\circ$'' and star ``$\ast$''.
\begin{description}
	\item Union works as an ``or'' operator, which means that the expression $0 \cup 1$ can either evaluate $0$ or $1$.
	\item Concatenation works as a ``followed by'' operator, which means the expression $0 \circ 1$ evaluates to $0$ followed by a $1$.
	\item Star works as a ``zero or more'' operator, meaning that the expression $0^{\ast}$ has an evaluation range from none to infinite $0$'s.
\end{description}
Summing up, the \ac{regex} $(0 \cup 1) \circ 0^{\ast}$ evaluates a $0$ or $1$ followed by zero or more $0$'s. \cite{syntax_book}\\

\subsection{\ac{cfgs}}
Every language, whether it is English, German, or some other language, have some specified grammar, used for making sentence in the languages. The grammar of the languages is specified by rules, which describe how to use the grammar correctly. \\
Every source code of a program, written in some programming language also consist of some sentence. Specify how a correct sentence in programming languages i written, the programming language uses a set of rules called the \textit{syntax} of the language. \\
The syntax of a programming language is usually described using an \ac{cfg}, which can be formed i different ways. Two of the most common forms is \ac{bnf} and \ac{ebnf}. \\
\\
\ac{cfgs} was first described in the middle of the 1950s by Noam Chromsky \cite{concepts_prog_lang}. A \ac{cfg} is a collection of substitutions rules. The rules consist of two kinds of symbols; \textit{nonterminals} also know as \textit{variable} and \textit{terminals}. Each rule in a \ac{cfg} is formed as a line. The line determines how to substitute one (ore more) \textit{variables} with another variable or terminal \cite{syntax_book}.

\subsubsection*{\ac{ebnf}}
The \ac{ebnf} notation is an extended version of the \ac{bnf} notation. Both the \ac{bnf} notation and the \ac{ebnf} notation are \ac{cfg}'s, and therefore used for describing syntax of programming languages. The \ac{bnf} notation was introduced by John Backus, and the was later modified by Peter Naur, hence the notation was called \ac{bnf}. \\
The \ac{bnf} notation has though time been extended i several ways, and even though all the extensions is not exactly the same, they are all called \ac{ebnf}. The extended notation was supposed to make the notation more readable and writeable. The \ac{bnf} notation and the \ac{ebnf} notation have the same power of description. \cite{concepts_prog_lang}


\begin{comment}
\begin{tabular}{l l l}
$< \texttt{if\_stmt}>$ & $\rightarrow$ $ \textbf{\texttt{if}} \; ( < \texttt{expression} > ) \;  < \texttt{statement} > \; [ \textbf{\texttt{else}} \; < \texttt{statement} > ]$
\end{tabular}

With use of \ac{bnf} the statement would be desriped \\

\begin{tabular}{l l l}
$< \texttt{if\_stmt}>$ & $\rightarrow$ &  $\textbf{\texttt{if}}  \; ( < \texttt{expression} > ) \;  < \texttt{statement} >$ \\
 & $|$ & $ \textbf{\texttt{if}} \; ( < \texttt{expression} > ) \;  < \texttt{statement} > \; \textbf{\texttt{else}} \; < \texttt{statement} > $
\end{tabular}
\end{comment}
\begin{comment}
An example of a \ac{cfg} from .

\begin{tabular}{l l l}
$A$ & $\rightarrow$ & $0A1$ \\
$A$ & $\rightarrow$ & $B$ \\
$B$ & $\rightarrow$ & $\#$ \\
\end{tabular}

In the gramma above the rules shows that $A$ can be substituted by either $0A1$ or $B$.

\subsection{\ac{bnf}}
The notation \ac{bnf}, is an form of a \ac{cfg}, and it was introduced by John Backus, and the notation was later modified by Peter Naur, and the notation was called \ac{bnf}\cite{concepts_prog_lang}. \\
\ac{bnf} is an other way of descriping syntax of a programming language. Like a \ac{cfg}, a \ac{bnf} is a collection of rules, which also uses \textit{terminals} and \textit{nonterminals}. An example of \ac{bnf} used to descripe a simple Java assignment statement is written as

\begin{tabular}{l l l}
$<\texttt{assign}>$ & $\rightarrow$ & $<\texttt{var}> \; = \; <\texttt{expression}>$ 
\end{tabular}

where $<\texttt{assign}>$ is an abstract representation of an assignment statement, and the rule specifies that $<\texttt{assign}>$ is defined as an instance of the abstraction $<\texttt{var}>$ followed by the `=' symbol, and then followed by the abstraction $<\texttt{expression}>$.
\end{comment}
